'''
A general n fold control gate 
Can combine with gate definitions from things we can do and some state registry definition
'''

def n_fold_controlled_gate(v, G, controls, target, Q):
    """
    Applies a controlled single-qubit gate based on a bitwise Algorithm.

    :param v: The quantum state vector (size 2^Q).
    :param G: A 2x2 matrix representing the single-qubit gate.
    :param control: Index of the control qubits (0-based).
    :param target: Index of the target qubit (0-based).
    :param Q: Total number of qubits.
    :return: Updated quantum state.

    leftmost bit corresponds to the most significant qubit. ie control = 1
    corresponds to leftmost bit in a 2 qubit system.
    """
    #ensures control qubits are passed through correctly
    if isinstance(controls, int):  
        controls = [controls]  # Convert to a list if it's a single integer
        
    new_v = np.copy(v)  # Copy the state vector

    for i in range(2**(Q)):  # loop over 2^(n-1) states
        if i & (1 << target) == 0:
            a = i  # State where target qubit is 0
            b = a | (1 << target)   # State where target qubit is 1

            # Making sure all control qubits are 1 in order to flip target
            if all((a & (1 << ctrl)) != 0 for ctrl in controls):
                #print statements to test that bit flipping is correct
                #print(f"Flipping target {target} for state {bin(a)[2:].zfill(Q)}")
                #print(f"Before swap: a={a} ({bin(a)[2:].zfill(Q)}), b={b} ({bin(b)[2:].zfill(Q)})")
                
                #getting correct indices to apply gates
                #bit values
                va = v[a]
                vb = v[b]

                new_va = G[0, 0] * va + G[0, 1] * vb
                new_vb = G[1, 0] * va + G[1, 1] * vb
                

                new_v[a] = new_va
                new_v[b] = new_vb

    return new_v
